---------------------------------------------------------------------------------
Файл info.c:

main: 
- проверяю количество параметров
- инициализирую список структур devicelist, объявленный в файле chipid.c
- вызываю функцию print_data (и передаю ей параметры программы).

print_data:
Смотрю, какие параметры переданы программе.
Если параметр --probe - вызываю функцию stlink_probe с параметрами по умолчанию
(connect: NORMAL, freq: 0)

stlink_probe:
Объявляю список структур для каждого подключенного ST-LINK'a
(stdevs: указатель на список указателей, указывающих на структуры).
Вызываю stlink_probe_usb с параметрами: 
- адрес stdevs'а (тройной указатель),
- connect,
- freq

Функция stlink_probe_usb заполняет stdevs и возвращает его размер.
Для каждого указателя вызываю функцию  stlink_print_info.

Потом освобождаю память, отведённую под stdevs.

stlink_print_info: просто печатаю в терминал информацию из переданной структуры 
ST-LINK'а.

---------------------------------------------------------------------------------
Файл usb.c:

stlink_probe_usb:
Инициализирую libusb
Получаю список USB-устройств (libusb_get_device_list).
Для полученного списка вызываю функцию stlink_probe_usb_devs.
Передаю ей:
- указатель на список указателей на структуры libusb_device (двойной указатель) devs
- адрес указателя на список указателей на структуры ST-LINK (тройной указатель) sldevs
- connect, freq.
Потом освобождаю память, занятую структурами libusb_device.
Список указателей на структуры ST-LINK возвращаю на выход (в функцию stlink_probe).

stlink_probe_usb_devs:
Определяю количество подключенных ST-LINK'ов:
Прохожу по списку USB-устройств.
Для каждого USB-устройства получаю дескриптор desc.
Если в дескрипторе указаны idVendor и idProduct, соответствующие ST-LINK'у - увеличиваю счётчик.
Выделяю память под нужное количество структур ST-LINK'ов.

Ещё раз прохожу по списку USB-устройств и получаю дескриптор каждого.
Если idProduct соответствует ST-LINK'у:
- открываю ST-LINK (libusb_open),
- читаю его серийник (stlink_serial);
- закрываю (libusb_close).

Если длина серийника правильная - открываю его функцией stlink_open_usb.
Она возвращает ссылку на структуру stlink_t. Пристёгиваю эту ссылку к списку структур.
Перехожу к следюущему USB-устройству. Потом записываю ссылку на список структур stlink_t
в указатель и возвращаю количество структур по списку.

stlink_serial:
Получаю дескриптор нулевой строки USB-устройства, беру из него LANGID (libusb_get_string_descriptor).
Получаю дескриптор строки серийника (для него нужен LANGID) (libusb_get_string_descriptor).
Если серийник длиной 50 символов - беру его же в формате ascii.
Если серийник длиной 26 символов - для каждого символа выполняю строку:
sprintf(serial + i, "%02X", desc_serial[i + 2])
В конце ставлю ноль.
Возвращаю длину серийника и сам серийник, записанный в память по адресу из параметра.

stlink_open_usb:
Выделяю в куче память под структуры sl (stlink_t) и slu (stlink_libusb).
Записываю в sl ссылку на список каких-то функций и ссылку на slu, указываю статус ядра
целевого MCU: TARGET_UNKNOWN.
Инициализирую libusb с контекстом, указываю LOG_LEVEL.
Получаю список USB-устройств.
Для каждого устройства получаю дескриптор и проверяю его idVendor.
Открываю устройство и пытаюсь получить серийник.
Если не получил серийник либо получил серийник, соответствующий заданному в параметре -
- выставляю в структуре sl версию и протокол по idProduct, после чего заканчиваю просмотр
устройств USB.

Просмотрев все устройства, открываю найденный ST-LINK и освобождаю память, занятую 
списком USB-устройств.

Читаю конфигурацию ST-LINK'а, потом устанавливаю её. Делаю заявку на интерфейс (libusb_claim_interface).
Потом выставляю поля ep_rep, ep_req, ep_trace, sg_transfer_idx и cmd_len.
Инициализирую версию ST-LINK'а (stlink_version).
Получаю режим работы ST-LINK'а. Если он в режиме dfu - выхожу из него.
Если CONNECT_UNDER_RESET: выхожу из debug mode, если в нём. Выполняю JTAG reset.
Выставляю поле freq по параметру функции, устанавливаю SWD clock (_stlink_usb_set_swdclk).
Выполняю stlink_target_connect и возвращаю структуру sl.

_stlink_usb_version:
Заполняю структуру stlink командой fill_command (по-разному для ST-LINK v. 3 и предыдущих версий)
Выполняю функцию send_recv


_stlink_usb_current_mode:
Заполняю структуру stlink командой fill_command, ставлю в i-тую позицию команду STLINK_GET_CURRENT_MODE
Вызываю функцию send_recv
Возвращаю первый символ буфера, или -1 при ошибке.

_stlink_usb_exit_debug_mode, _stlink_usb_exit_debug_mode:
Заполняю структуру stlink командой fill_command, ставлю в i-тую позицию команды:
STLINK_DFU_COMMAND
STLINK_DFU_EXIT
Вызываю функцию send_only
Возвращаю 0, или -1 при ошибке.
То же самое для debug

fill_command:
Для ST-LINK v. 1 заполняю поле c_buf структуры stlink. Для всех остальных заполняю его нулями.

send_recv:
Отправляю функцией libusb_bulk_transfer данные в параметре txbuf и команду в cmd.
Проверяю ответ на ошибки и если указан rxsize - принимаю данные той же функцией.
Возвращаю количество принятого после проверки на ошибки.

---------------------------------------------------------------------------------
Файл common.c:

stlink_version:
Запускаю функцию version из backend (вызывается _stlink_usb_version из usb.c)
Выполняю _parse_version.

stlink_current_mode:
возвращаю результат выполнения функции sl->backend->current_mode(sl) после проверки на ошибки.
При этом запускается функция _stlink_usb_current_mode.